# Resources:
- https://learning.oreilly.com/course/core-java-11/9780135160053/
- https://horstmann.com/corejava/livelessons/lesson08/index.html#(1)

# Type parameters
- Before type parameters, Java used inheritance in ArrayList with add(Object o), get(Object o) but the problem was that 
if in an arraylist of strings, file type was added, the add method would not complain because it could add any Object there. 
But this situation will later result in a ClassCastException when file would be accessed as String. 
The problem would appear at a different place than it actually happened.
- Type parameters bring compile type safety (whereas in Object parameters, safety could only be checked at run time)
![image](https://github.com/user-attachments/assets/f1360063-bddd-43f8-ac54-6e93e12aca02)

------------------------------------------------------------------------------------------------------------------

# Possible heap pollution from parameterized vararg type
  ![img.png](img.png)

## Heap Pollution
Heap pollution occurs when a variable of a parameterized type holds an object that is not of that type. This happens because of the way generics are implemented in Java due to type erasure. At runtime, the actual generic types are removed, so the JVM doesn't track the type parameter information for generics. If type safety is not ensured at compile-time, this can lead to runtime errors such as ClassCastException.

## How It Happens with Varargs
Varargs in Java allow you to pass a variable number of arguments to a method. Internally, varargs are converted to arrays, but arrays are covariant in Java, meaning that an array of a supertype can hold a subtype. Generics, however, are invariant.

When you use varargs with generic types, type erasure and array covariance can lead to unsafe situations.
For example, if a method accepts a varargs parameter of a generic type, Java will create an array to hold those arguments, but due to type erasure, this array will not contain type information. The result is a warning, since there is a possibility of heap pollution—where the array contains elements of a type different from the expected parameterized type.

## Summary of Key Points
1. Heap pollution can occur when using varargs with generic types, leading to potential runtime ClassCastException due to type erasure. If you mix different parameterized types like List<String> and List<Integer> in a varargs array, you could later mistakenly retrieve an Integer from a List<String>, leading to a ClassCastException.
2. Use `@SafeVarargs` if you know your method is type-safe and doesn't introduce heap pollution. This annotation is allowed on methods that do not modify the contents of the varargs array or expose it in an unsafe way.
3. Avoid varargs with generics when possible. Prefer explicitly passing collections or arrays to retain type safety.
4. Use wildcards (List<?>...) for flexibility, but be aware that you'll lose the specific type information.

# Reason for Using `extends` in Generics
  In Java, when specifying **type bounds** in generic declarations, the keyword `extends` is used for both classes and interfaces. This is a design choice by Java to simplify the generics system as this keeps the syntax consistent.
```java
public class MyClass<T extends Number & Comparable<T>> {
    // T must extend the class Number and implement Comparable<T>
}
```
------------------------------------------------------------------------------------------------------------------
# Bridge Methods
  Bridge methods in Java are a compiler-generated feature used to maintain compatibility between generic types and the type erasure mechanism used by the JVM. They help ensure that when generics are used with subclassing or method overriding, the Java runtime can still find and invoke the correct methods.

**Why Bridge Methods Are Needed:**
When Java introduced generics, it used type erasure, meaning that the type information is erased at runtime for backward compatibility. This can create a situation where a subclass overrides a method with a generic signature, but due to type erasure, the JVM can no longer distinguish between the original and the overridden method. The compiler generates a bridge method to ensure that the correct method is called at runtime.

```java
class Animal implements Comparable<Animal> {
    public int compareTo(Animal a) {
        return 0;
    }
}

class Dog extends Animal {
    @Override
    public int compareTo(Animal a) {
        return 1;
    }
}
```

```java
class Dog extends Animal {
    // The actual overridden method
    @Override
    public int compareTo(Animal a) {
        return 1;
    }

    // Bridge method generated by the compiler to override method defined in Animal
    @Override
    public int compareTo(Object o) {
        return compareTo((Animal) o); // Delegates to compareTo(Animal a)
    }
}
```

![image](https://github.com/user-attachments/assets/b1cbabbd-edbc-4432-9e8d-d7025f039602)
![image](https://github.com/user-attachments/assets/6eeaa534-e462-4a46-a26b-e8621ee637ab)

------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------

# Restrictions & Limitations of Java Generics
![img_2.png](img_2.png)
![img_3.png](img_3.png)
![img_4.png](img_4.png)

## Varargs warnings 
* Use `@SafeVarargs` if you know your method is type-safe and doesn't introduce heap pollution. This annotation is allowed on methods that do not modify the contents of the varargs array or expose it in an unsafe way.
* `@SafeVarargs`: In addition to the usage restrictions imposed by its `@Target({ElementType. CONSTRUCTOR,ElementType. METHOD})` meta-annotation, compilers are required to implement additional usage restrictions on this annotation type; it is a compile-time error if a method or constructor declaration is annotated with a `@SafeVarargs` annotation, and either:
  * the declaration is a fixed arity method or constructor
  * the declaration is a variable arity method that is neither `static` nor `final` nor `private`.

## Cannot instantiate a generic type
![img_5.png](img_5.png)
![img_6.png](img_6.png)

## Constructing Generic Arrays
![img_7.png](img_7.png)
![image](https://github.com/user-attachments/assets/6289e027-d33a-44d6-9397-1a168bfd83a1)
![image](https://github.com/user-attachments/assets/742bacca-1cf2-453c-b502-bce49c01a3f9)
![image](https://github.com/user-attachments/assets/d1fe9487-e81f-4ec5-82b6-ad7b11871458)
![image](https://github.com/user-attachments/assets/84c4b464-2407-4645-9c3a-d4fb4d42751f)
![image](https://github.com/user-attachments/assets/5bdd48cd-3a68-4f60-ae02-c66b04a50b97)

# `extends` vs `super`

In Java Generics, `extends` and `super` are used with wildcards to provide flexibility when specifying the types that can be accepted or returned by generic methods or classes. They define bounds or restrictions on the types, helping control how types are used and ensuring type safety. Let's break them down:

### 1. **`? extends T` (Upper Bounded Wildcard)**

- **Meaning**: The wildcard can be any type that **is a subtype of `T` or `T` itself**.
- **Usage**: You use `? extends T` when you want to read data from a generic structure but don't intend to modify it (you are limiting the types you accept to `T` and its subclasses).
- **Example**: This allows you to **read** values of type `T` or its subtypes but **not write** new values into the structure, except `null`.

#### Example:
```java
public static void printList(List<? extends Number> list) {
    for (Number num : list) {
        System.out.println(num);
    }
}
```
- **`List<? extends Number>`** means that the list can contain elements that are of type `Number` or any subclass of `Number` (e.g., `Integer`, `Double`, etc.).
- You can read from this list because you know the elements will be at least `Number` or its subclasses.
- You cannot add elements to the list (except `null`) because the exact type of elements is unknown at compile time—it could be `Integer`, `Double`, or some other subclass.

### 2. **`? super T` (Lower Bounded Wildcard)**

- **Meaning**: The wildcard can be any type that **is a supertype of `T` or `T` itself**.
- **Usage**: You use `? super T` when you want to **write** data to a generic structure, but you don't care about reading from it in a type-safe way.
- **Example**: This allows you to **write** values of type `T` or its subclasses but **not read** elements as anything more specific than `Object`.

#### Example:
```java
public static void addIntegers(List<? super Integer> list) {
    list.add(1);
    list.add(2);
}
```
- **`List<? super Integer>`** means the list can accept elements that are `Integer` or any superclass of `Integer` (e.g., `Number`, `Object`).
- You can add `Integer` values to the list because the list must be able to hold at least `Integer` or its superclasses.
- You cannot guarantee what type the elements are when reading from the list, so reading will only be safe as `Object`.

### Key Difference: `extends` vs `super`

- **`extends`**: Use this when you want to **read** data from a structure but you’re not going to add any new data (except `null`). It makes sense when you're looking to get more specific subtypes of a type.
- **`super`**: Use this when you want to **write** data into a structure. This is useful when you’re inserting items, ensuring that the structure can hold the type or any of its supertypes.

### Practical Example with Both `extends` and `super`:

Suppose you have a class hierarchy:
```java
class Animal {}
class Dog extends Animal {}
class Cat extends Animal {}
```

#### **Using `extends`**:
```java
List<? extends Animal> animals = new ArrayList<Dog>();
// Can read as Animal (or its subtypes) but cannot add anything except null
Animal animal = animals.get(0); // Safe to read as Animal
// animals.add(new Dog()); // Error: cannot add anything because the exact type is unknown
```

#### **Using `super`**:
```java
List<? super Dog> animals = new ArrayList<Animal>();
// Can add Dog or its subclasses but can only safely read as Object
animals.add(new Dog());  // Can add Dog
// Dog dog = animals.get(0); // Error: cannot guarantee the type, so must cast
Object obj = animals.get(0); // Can only safely read as Object
```

### Summary:

- **`? extends T`**:
  - You can read elements as type `T` or its subclasses.
  - You cannot add elements (except `null`) because you don't know the specific type at runtime.
  - Example use case: You are working with a list of elements and want to ensure they are all `T` or a subclass of `T`, but you are only reading data.

- **`? super T`**:
  - You can add elements of type `T` or its subclasses.
  - You can only read elements as type `Object`, as the actual type is not known.
  - Example use case: You are modifying a list and want to ensure you can add `T` or a subclass, but you don't need to read from it.

Understanding how to use `extends` and `super` effectively helps ensure flexibility while maintaining type safety in generic methods and classes.
# Generic types and Inheritance

## Inheritance and Subtype relationships
![image](https://github.com/user-attachments/assets/17a26e9b-9a6a-4261-a1eb-458b838e6e1d)
![image](https://github.com/user-attachments/assets/b765b284-2d4a-4965-a2ce-08335acf3942)

## Wildcard types
![image](https://github.com/user-attachments/assets/225c9edc-2042-4b4d-838b-3ff318f5b26a)

## Use ? extends for Producers
![image](https://github.com/user-attachments/assets/cdea1527-5ba3-4c3a-86b4-bbc8c9ed44f8)

## Supertype Bounds
![image](https://github.com/user-attachments/assets/37f9f214-dd47-41fd-b452-70a3e39f817f)

## Complex Wildcards
- Generic Comparable interface:
```java
public interface Comparable<T>
{
   public int compareTo(T other);
}
```
Let's use it in min:
```java
public static <T extends Comparable<T>> T min(T[] a)
```
- Works fine with `String` which implements the `Comparable<String>` interface.
- But it doesn't work with a `LocalDate` array!
  - `LocalDate` implements `ChronoLocalDate`
  - `ChronoLocalDate` extends `Comparable<ChronoLocalDate>`
  - `LocalDate` does not implement `Comparable<LocalDate>` because the bridge methods would clash
- Remedy:
```java
public static <T extends Comparable<? super T>> T min(T[] a) . . .
```

## Unbounded Wildcards
Can you do anything with the Pair<?> type?
```java
? getFirst()
void setFirst(?)
```
Here is an example:
```java
public static boolean hasNulls(Pair<?> p)
{
   return p.getFirst() == null || p.getSecond() == null;
}
```
Could have used a generic method:
```java
public static <T> boolean hasNulls(Pair<T> p)
```
But the wildcard looks nicer.

## Wildcard Capture
Write a method that swaps the elements of a pair:
```java
public static void swap(Pair<?> p)
```
The obvious approach doesn't work:
```java
? t = p.getFirst(); // Error
p.setFirst(p.getSecond());
p.setSecond(t);
```
Define helper method:
```java
public static <T> void swapHelper(Pair<T> p)
{
   T t = p.getFirst();
   p.setFirst(p.getSecond());
   p.setSecond(t);
}
```
Call helper method:
```java
public static void swap(Pair<?> p) { swapHelper(p); }
```
We don't know what ? is, but it is a definite type that can be “captured” in the call `<definite type>swapHelper`.























